{"posts":[{"title":"SpringBoot Jpa 的使用","content":"Spring Boot Jpa 介绍 Jpa 是什么？ Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象/关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。 值得注意的是，Jpa是在充分吸收了现有 Hibernate，TopLink，JDO 等 ORM 框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，Jpa 受到了极大的支持和赞扬，其中就包括了 Spring 与 EJB3. 0的开发团队。 注意：Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。 Spring Boot Jpa Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data Jpa 可以极大提高开发效率！ Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现。 基本查询 基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。 预先生成方法 继承 JpaRepository Spring Boot Jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等 public interface UserRepository extends JpaRepository&lt;User, Long&gt; { } - 使用默认方法 ```java @Test public void testBaseQuery() throws Exception { User user=new User(); userRepository.findAll(); userRepository.findOne(1l); userRepository.save(user); userRepository.delete(user); userRepository.count(); userRepository.exists(1l); // ... } 自定义简单查询 自定义的简单查询就是根据方法名来自动生成 SQL，主要的语法是findXXBy,readAXXBy,queryXXBy,countXXBy, getXXBy后面跟属性名称： User findByUserName(String userName); 也使用一些加一些关键字And 、 Or User findByUserNameOrEmail(String username, String email); 修改、删除、统计也是类似语法 Long deleteById(Long id); Long countByUserName(String userName) 基本上 SQL 体系中的关键词都可以使用，例如： LIKE 、 IgnoreCase、 OrderBy。 List&lt;User&gt; findByEmailLike(String email); User findByUserNameIgnoreCase(String userName); List&lt;User&gt; findByUserNameOrderByEmailDesc(String email); 复杂查询 在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义 SQL 分页查询 分页查询在实际使用中非常普遍了，Spring Boot Jpa 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数Pageable ,当查询中有多个参数的时候Pageable建议做为最后一个参数传入. Page&lt;User&gt; findALL(Pageable pageable); Page findByUserName(String userName,Pageable pageable); - Pageable 是 Spring 封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则 ```java @Test public void testPageQuery() throws Exception { int page=1,size=10; Sort sort = new Sort(Direction.DESC, &quot;id&quot;); Pageable pageable = new PageRequest(page, size, sort); userRepository.findALL(pageable); userRepository.findByUserName(&quot;testName&quot;, pageable); } 限制查询 有时候我们只需要查询前N个元素，或者支取前一个实体。 User findFirstByOrderByLastnameAsc(); User findTopByOrderByAgeDesc(); Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable); List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort); List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable); 自定义SQL查询 其实 Spring Data 觉大部分的 SQL 都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的 SQL 来查询，Spring Data 也是完美支持的；在 SQL 的查询方法上面使用@Query注解，如涉及到删除和修改在需要加上@Modifying.也可以根据需要添加 @Transactional对事物的支持，查询超时的设置等。 @Modifying @Query(&quot;update User u set u.userName = ?1 where u.id = ?2&quot;) int modifyByIdAndUserId(String userName, Long id); @Transactional @Modifying @Query(&quot;delete from User where id = ?1&quot;) void deleteByUserId(Long id); @Transactional(timeout = 10) @Query(&quot;select u from User u where u.emailAddress = ?1&quot;) User findByEmailAddress(String emailAddress); 多表查询 多表查询 Spring Boot Jpa 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。 首先需要定义一个结果集的接口类。 public interface HotelSummary { City getCity(); String getName(); Double getAverageRating(); default Integer getAverageRatingRounded() { return getAverageRating() == null ? null : (int) Math.round(getAverageRating()); } } 查询的方法返回类型设置为新创建的接口 @Query(&quot;select h.city as city, h.name as name, avg(r.rating) as averageRating &quot; - &quot;from Hotel h left outer join h.reviews r where h.city = ?1 group by h&quot;) Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable); @Query(&quot;select h.name as name, avg(r.rating) as averageRating &quot; - &quot;from Hotel h left outer join h.reviews r group by h&quot;) Page&lt;HotelSummary&gt; findByCity(Pageable pageable); 使用 Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, &quot;name&quot;)); for(HotelSummary summay:hotels){ System.out.println(&quot;Name&quot; +summay.getName()); } ","link":"https://1958818905.github.io/post/springboot/"},{"title":"Spring Boot：Spring Boot 中 Redis 的使用","content":"Spring Boot 对常用的数据库支持外，对 Nosql 数据库也进行了封装自动化。 Redis 介绍 Redis 是目前业界使用最广泛的内存数据存储。相比 Memcached，Redis 支持更丰富的数据结构，例如 hashes, lists, sets 等，同时支持数据持久化。除此之外，Redis 还提供一些类数据库的特性，比如事务，HA，主从库。可以说 Redis 兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍 Redis 在 Spring Boot 中两个典型的应用场景。 如何使用 引入依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; org.apache.commons commons-pool2 ``` - Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redisspring-boot-starter-data-redis依赖于spring-data-redis 和 lettuce 。Spring Boot 1.0 默认使用的是 Jedis 客户端，2.0 替换成 Lettuce，但如果你从 Spring Boot 1.5.X 切换过来，几乎感受不大差异，这是因为 spring-boot-starter-data-redis 为我们隔离了其中的差异性。 - Lettuce 是一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 netty NIO 框架来高效地管理多个连接。 2. 添加配置文件 ``` # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器地址 spring.redis.host=localhost # Redis服务器连接端口 spring.redis.port=6379 # Redis服务器连接密码（默认为空） spring.redis.password= # 连接池最大连接数（使用负值表示没有限制） 默认 8 spring.redis.lettuce.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1 spring.redis.lettuce.pool.max-wait=-1 # 连接池中的最大空闲连接 默认 8 spring.redis.lettuce.pool.max-idle=8 # 连接池中的最小空闲连接 默认 0 spring.redis.lettuce.pool.min-idle=0 ``` 3. 添加 cache 的配置类 ``` @Configuration @EnableCaching public class RedisConfig extends CachingConfigurerSupport{ @Bean public KeyGenerator keyGenerator() { return new KeyGenerator() { @Override public Object generate(Object target, Method method, Object... params) { StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) { sb.append(obj.toString()); } return sb.toString(); } }; } } - 注意我们使用了注解：@EnableCaching来开启缓存。 4. 直接使用 @RunWith(SpringRunner.class) @SpringBootTest public class TestRedis { @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate redisTemplate; @Test public void test() throws Exception { stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;); Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;)); } @Test public void testObj() throws Exception { User user=new User(&quot;aa@126.com&quot;, &quot;aa&quot;, &quot;aa123456&quot;, &quot;aa&quot;,&quot;123&quot;); ValueOperations&lt;String, User&gt; operations=redisTemplate.opsForValue(); operations.set(&quot;com.neox&quot;, user); operations.set(&quot;com.neo.f&quot;, user,1, TimeUnit.SECONDS); Thread.sleep(1000); //redisTemplate.delete(&quot;com.neo.f&quot;); boolean exists=redisTemplate.hasKey(&quot;com.neo.f&quot;); if(exists){ System.out.println(&quot;exists is true&quot;); }else{ System.out.println(&quot;exists is false&quot;); } // Assert.assertEquals(&quot;aa&quot;, operations.get(&quot;com.neo.f&quot;).getUserName()); } } - 以上都是手动使用的方式，如何在查找数据库的时候自动使用缓存呢，看下面； 5. 自动根据方法生成缓存 @RestController public class UserController { @RequestMapping(&quot;/getUser&quot;) @Cacheable(value=&quot;user-key&quot;) public User getUser() { User user=new User(&quot;aa@126.com&quot;, &quot;aa&quot;, &quot;aa123456&quot;, &quot;aa&quot;,&quot;123&quot;); System.out.println(&quot;若下面没出现“无缓存的时候调用”字样且能打印出数据表示测试成功&quot;); return user; } } - 其中 value 的值就是缓存到 Redis 中的 key ","link":"https://1958818905.github.io/post/spring-bootspring-boot-zhong-redis-de-shi-yong/"},{"title":"SpringBoot注解","content":"SpringBoot注解的优缺点 优点 快速构建项目。 对主流开发框架的无配置集成。 项目可独立运行，无须外部依赖Servlet容器。 提供运行时的应用监控。 极大的提高了开发、部署效率。 与云计算的天然集成。 缺点： 版本迭代速度很快，一些模块改动很大 由于不用自己做配置，报错时很难定位 网上现成的解决方案比较少 注解 SpringBootApplication – 主配置类 效果：说明这个类就是SpringBoot的主配置类，SpringBoot就应该运行主配置类的main方法执行程序。 @SpringBootApplication public class SpringBootMaven { public static void main(String[] args) { SpringApplication.run(SpringBootMaven.class, args); } } 继承@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan @SpringBootConfiguration：继承@Configuration，Spring配置注解，将当前类声明的一个或多个@Bean注解标记的方法纳入Spring容器，实例名就是方法名. @EnableAutoConfiguration：继承@AutoConfigurationPackage， 导入了AutoConfigurationImportSelector.class AutoConfigurationPackages.Registrar.class根据添加的jar包来配置项目的默认配置。 @ComponentScan：扫描当前包及其子包下被@Component，@Controller，@Service， @Repository注解标记的类并纳入到spring容器中进行管理 EnableAutoConfiguration -自动装配 效果：借助AutoConfigurationImportSelector.class，为SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器 @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) @RestController – 控制器 @RestController == @ResponseBody + @Controller @ResponseBody：标记在类上，表示类下所有方法返回一条语句给网站，@Controller：标记当前类为控制器. @RestController public class SpringbootiniApplication { @RequestMapping(&quot;/&quot;) String hello(){ return &quot;hello world quick&quot;; } } @ConfigurationProperties – 配置属性绑定 把全局/主配yml/properties的配置信息注入到POJO（全局 &gt; application.yml/properties） 需要把当前类标记为组件（@Component），添加属性prefix = “xx”，xx为yml里的key @Component @ConfigurationProperties(prefix = &quot;person&quot;) public class Person { int age; String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 而且根据SpringBoot文档，还需要添加依赖处理器 &lt;!-- yml依赖处理器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 然后重新启动springboot @PropertySource – 引入SpringBoot配置 当@ConfigurationProperties需要从副配置文件拿数据时，可用@PropertySource手动引入副配置，value可指定多个路径 @Component @ConfigurationProperties(prefix = &quot;person&quot;) @PropertySource(value = {&quot;classpath:person.properties&quot;}) public class Person { int age; String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 相同key优先级：全局配置 &gt; 副配置 上面用person.properties而不用person.yml不是没有原因的，yml除了主配，其他配置不生效 @ImportSource – 引入Spring配置@ImportSource – 引入Spring配置 在SpringBoot中，引入bean.xml（Spring配置文件），需要在主类配置该注解，可导入多个配置文件 @SpringBootApplication @ImportResource(locations = {&quot;classpath:bean.xml&quot;}) public class SpringbootiniApplication { public static void main(String[] args) { SpringApplication.run(SpringbootiniApplication.class, args); } } @Configuration – 注解代替Spring配置 Spring注解，标记类后当前类成配置类，当前类的@Bean注解即 applicationContext.xml == @Configuration + @Bean + @ComponentSca… SpringBoot推荐 =&gt; 注解代替配置文件 @Configuration public class MyAppConfig { @Bean public Student student(){ System.out.println(&quot;@bean is ok&quot;); return new Student(); } } class Student{} @Bean：将方法返回值添加到容器中；容器中这个组件默认id就是方法名 @ResponseBody – 文本返回 标注方法上，如果你有返回值，返回值变文本格式输出，若没有标注，则分发器会走视图解析器，然后报错说/template下找不到视图，如果你只是ajax异步回来处理数据存储，不需要返回页面则无需标注 @RequestMapping(&quot;/login&quot;) @ResponseBody public User login(User user){ return user; } User字段：userName pwd 那么在前台接收到的数据为：’{“userName”:“xxx”,“pwd”:“xxx”}’ @Transactional – 事务 如下有一个保存用户的方法，加入 @Transactional 注解，使用默认配置，抛出异常之后，事务会自动回滚，数据不会插入到数据库。 @Transactional public void save() { User user = new User(&quot;服部半藏&quot;); userMapper.insertSelective(user); if (true) { throw new RuntimeException(&quot;save 抛异常了&quot;); } } @Param – 绑定EL和参数 mybatis提示类型绑定问题 @Select(&quot;select * from myuser where loginname=#{loginname} and password=#{password}&quot;) User findWithLoginnameAndPassword(@Param(&quot;loginname&quot;)int loginname, @Param(&quot;password&quot;)String password); ","link":"https://1958818905.github.io/post/ce-shi/"}]}