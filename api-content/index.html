{"posts":[{"title":"简单的Springboot案例","content":"一、导入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 二、连接数据库 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;charactEnoding=utf-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai username: root password: root initiaSize: 20 minIdle: 50 maxActive: 500 jpa: hibernate: ddl-auto: update show-sql: true server: port: 8080 三、创建文件 在entity下创建User package com.example.demo1.entity; import lombok.Data; import javax.persistence.*; import java.io.Serializable; import java.math.BigDecimal; import java.sql.Timestamp; @Table(name = &quot;sys_user&quot;) @Entity @Data public class User implements Serializable { @Id private Integer id; private String student_name; private Integer result; private Timestamp create_time; private Long update_user; private String remark; } 在dao下创建UserDao package com.example.demo1.dao; import com.example.demo1.entity.User; import org.springframework.data.jpa.repository.JpaRepository; import java.util.List; public interface UserDao extends JpaRepository&lt;User, Integer&gt; { User findById(int id); } 在Service下创建UserService和RedisService UserService package com.example.demo1.service; import com.example.demo1.entity.User; import java.util.List; public interface UserService { /** * 保存用户 * * @param user * @return */ User save(User user); /** * 根据主键删除用户 * * @param id */ void deleteUserById(int id); /** * 根据主键查询 * * @param id * @return */ User queryById(int id); List&lt;User&gt; queryAll(); } RedisServicepackage com.example.demo1.service; public interface RedisService { /** * 储存数据 * * @param key * @param value */ void set(String key, String value); /** * 获取数据 * * @param key * @return */ String get(String key); /** * 设置超期时间 * * @param key * @param expire * @return */ boolean expire(String key, long expire); /** * 删除数据 * * @param key */ void remove(String key); /** * 自增操作 * * @param key * @param delta 自增步长 * @return */ Long incream(String key, long delta); } 4. 在Service下的impl下创建UserServiceImpl和RedisServiceImpl - UserServiceImpl ```java package com.example.demo1.service.impl; import com.example.demo1.dao.UserDao; import com.example.demo1.entity.User; import com.example.demo1.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public User save(User user) { return userDao.save(user); } @Override public void deleteUserById(int id) { userDao.deleteById(id); } @Override public User queryById(int id) { return userDao.getOne(id); } @Override public List&lt;User&gt; queryAll() { return userDao.findAll(); } } RidisServiceImpl package com.example.demo1.service.impl; import com.example.demo1.service.RedisService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Service; import java.security.Key; import java.util.concurrent.TimeUnit; @Service public class RedisServiceImpl implements RedisService { @Autowired private StringRedisTemplate stringRedisTemplate; @Override public void set(String key, String value) { stringRedisTemplate.opsForValue().set(key, value); } @Override public String get(String key) { return stringRedisTemplate.opsForValue().get(key); } @Override public boolean expire(String key, long expire) { return stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS); } @Override public void remove(String key) { stringRedisTemplate.delete(key); } @Override public Long incream(String key, long delta) { return stringRedisTemplate.opsForValue().increment(key, delta); } } 创建controller并在其下创建IndexController和UserController UserController package com.example.demo1.controller; import com.example.demo1.entity.User; import com.example.demo1.service.RedisService; import com.example.demo1.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(&quot;user&quot;) public class UserController { @Autowired private UserService userService; @Autowired private RedisService redisService; @GetMapping(&quot;/queryById&quot;) public String queryById(int id) { String userStr = redisService.get(id + &quot;&quot;); if (userStr != null) { redisService.set(id + &quot;&quot;, userService.queryById(id).toString()); } return userStr; } @PostMapping(&quot;/save_or_update&quot;) public User save_or_update(User user) { return userService.save(user); } @DeleteMapping(&quot;/Delete&quot;) public Boolean Delete(int id) { userService.deleteUserById(id); return true; } } IndexController package com.example.demo1.controller; import com.example.demo1.entity.User; import com.example.demo1.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import java.util.ArrayList; import java.util.List; @Controller public class IndexController { @Autowired private UserService userService; @RequestMapping(&quot;/&quot;) public String index(ModelMap map) { map.addAttribute(&quot;host&quot;, &quot;内蒙古电子&quot;); return &quot;index&quot;; } @RequestMapping(&quot;/echarts&quot;) public String echarts() { return &quot;echarts&quot;; } @RequestMapping(&quot;/echartx&quot;) public String echartx(ModelMap map) { List&lt;User&gt; users = userService.queryAll(); List&lt;String&gt; names = new ArrayList&lt;&gt;(); List&lt;Integer&gt; sorces = new ArrayList&lt;&gt;(); if (users != null &amp;&amp; users.size() &gt; 0) { users.stream().forEach(user -&gt; { names.add(user.getStudent_name()); sorces.add(user.getResult()); }); } map.addAttribute(&quot;names&quot;, names); map.addAttribute(&quot;sorces&quot;, sorces); return &quot;echartsx&quot;; } } 在config下创建Swagger2Config package com.example.demo1.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class Swagger2Config { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo1.controller&quot;)) // .apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) // .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;SwaggerUI演示&quot;) .description(&quot;内蒙古电子信息技术职业学院&quot;) .contact(&quot;gsj&quot;) .version(&quot;1.0&quot;) .build(); } } 在resources下创建templates文件夹并在其下创建echarts和echartsx echarts &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Spring Boot中使用ECharts&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.6.0/echarts.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot; style=&quot;width: 1000px;height:400px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; let myChart = echarts.init(document.getElementById('main')); option = { xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [820, 932, 901, 934, 1290, 1330, 1320], type: 'line' }] }; myChart.setOption(option); &lt;/script&gt; &lt;/html&gt; echartsx &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Spring Boot中使用ECharts&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.6.0/echarts.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot; style=&quot;width: 1000px;height:400px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; let myChart = echarts.init(document.getElementById('main')); option = { xAxis: { type: 'category', data: [[${names}]] }, yAxis: { type: 'value' }, series: [{ data: [[${sorces}]], type: 'line' }] }; myChart.setOption(option); &lt;/script&gt; &lt;/html&gt; ","link":"https://1958818905.github.io/post/jian-dan-de-springboot-an-li/"},{"title":"Mybatis（二） 多数据源最简解决方案","content":"配置文件 mybatis.config-location=classpath:mybatis/mybatis-config.xml spring.datasource.test1.jdbc-url=jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true spring.datasource.test1.username=root spring.datasource.test1.password=root spring.datasource.test1.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.test2.jdbc-url=jdbc:mysql://localhost:3306/test2?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true spring.datasource.test2.username=root spring.datasource.test2.password=root spring.datasource.test2.driver-class-name=com.mysql.cj.jdbc.Driver 数据源配置 @Configuration @MapperScan(basePackages = &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef = &quot;test1SqlSessionTemplate&quot;) public class DataSource1Config { @Bean(name = &quot;test1DataSource&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.test1&quot;) @Primary public DataSource testDataSource() { return DataSourceBuilder.create().build(); } @Bean(name = &quot;test1SqlSessionFactory&quot;) @Primary public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) throws Exception { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis/mapper/test1/*.xml&quot;)); return bean.getObject(); } @Bean(name = &quot;test1TransactionManager&quot;) @Primary public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean(name = &quot;test1SqlSessionTemplate&quot;) @Primary public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception { return new SqlSessionTemplate(sqlSessionFactory); } } 最关键的地方就是这块了，一层一层注入,首先创建 DataSource，然后创建 SqlSessionFactory 再创建事务，最后包装到 SqlSessionTemplate 中。其中需要指定分库的 mapper 文件地址，以及分库dao层代码 @MapperScan(basePackages = &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef = &quot;test1SqlSessionTemplate&quot;) 这块的注解就是指明了扫描 dao 层，并且给 dao 层注入指定的 SqlSessionTemplate。所有@Bean都需要按照命名指定正确。 dao 层和 xml层 dao 层和 xml 需要按照库来分在不同的目录public interface User1Mapper { List&lt;UserEntity&gt; getAll(); UserEntity getOne(Long id); void insert(UserEntity user); void update(UserEntity user); void delete(Long id); } -xml层 ```java &lt;mapper namespace=&quot;com.neo.mapper.test1.User1Mapper&quot; &gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.neo.model.User&quot; &gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&gt; &lt;result column=&quot;userName&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;passWord&quot; property=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;result column=&quot;user_sex&quot; property=&quot;userSex&quot; javaType=&quot;com.neo.enums.UserSexEnum&quot;/&gt; &lt;result column=&quot;nick_name&quot; property=&quot;nickName&quot; jdbcType=&quot;VARCHAR&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot; &gt; id, userName, passWord, user_sex, nick_name &lt;/sql&gt; &lt;select id=&quot;getAll&quot; resultMap=&quot;BaseResultMap&quot; &gt; SELECT &lt;include refid=&quot;Base_Column_List&quot; /&gt; FROM users &lt;/select&gt; &lt;select id=&quot;getOne&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot; &gt; SELECT &lt;include refid=&quot;Base_Column_List&quot; /&gt; FROM users WHERE id = #{id} &lt;/select&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.neo.model.User&quot; &gt; INSERT INTO users (userName,passWord,user_sex) VALUES (#{userName}, #{passWord}, #{userSex}) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.neo.model.User&quot; &gt; UPDATE users SET &lt;if test=&quot;userName != null&quot;&gt;userName = #{userName},&lt;/if&gt; &lt;if test=&quot;passWord != null&quot;&gt;passWord = #{passWord},&lt;/if&gt; nick_name = #{nickName} WHERE id = #{id} &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Long&quot; &gt; DELETE FROM users WHERE id =#{id} &lt;/delete&gt; &lt;/mapper&gt; 测试 测试可以使用 SpringBootTest,也可以放到 Controller中，这里只贴 Controller 层的使用 @RestController public class UserController { @Autowired private User1Mapper user1Mapper; @Autowired private User2Mapper user2Mapper; @RequestMapping(&quot;/getUsers&quot;) public List&lt;UserEntity&gt; getUsers() { List&lt;UserEntity&gt; users=user1Mapper.getAll(); return users; } @RequestMapping(&quot;/getUser&quot;) public UserEntity getUser(Long id) { UserEntity user=user2Mapper.getOne(id); return user; } @RequestMapping(&quot;/add&quot;) public void save(UserEntity user) { user2Mapper.insert(user); } @RequestMapping(value=&quot;update&quot;) public void update(UserEntity user) { user2Mapper.update(user); } @RequestMapping(value=&quot;/delete/{id}&quot;) public void delete(@PathVariable(&quot;id&quot;) Long id) { user1Mapper.delete(id); } } ","link":"https://1958818905.github.io/post/mybatiser-duo-shu-ju-yuan-zui-jian-jie-jue-fang-an/"},{"title":"Spring-Boot中MyBatis的使用和配置(一)","content":"什么是mybatis MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。 MyBatis 有以下特点： 简单易学，小且简单：没有第三方依赖，最简单安装只要两个jar包+配置几个sql映射文件，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射。 提供对象关系映射标签，支持对象关系组建维护。 提供xml标签，支持编写动态sql。 入门实例 1. 引用依赖 单独使用 mybatis，只需引入mybatis-x.x.x.jar 和相关的数据库连接包就行。 使用 maven 的 dependency 配置为 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; 2.mybatis配置和 xml映射文件配置 每个基于 MyBatis 的应用都是以一个SqlSessionFactory的实例为中心的。 SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder获得。 而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 mybatis XML 配置 MyBatis 的XML配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）这里先给出一个用 xml 配置的简单示例 mybatis-config.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 环境配置：事务管理器和数据源配置 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/brave/dao/mapper/UpmsUserMapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 数据源属性文件 database.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/shiyu?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8 jdbc.username=zou jdbc.password=****** 通过配置文件我们可以从中构建 SqlSessionFactory 的实例 inputStream = Resources.getResourceAsStream(&quot;conf/mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); xml映射文件配置 我们从上面的配置可以看到有映射器的配置 &lt;mapper resource=&quot;com/brave/dao/mapper/UpmsUserMapper.xml&quot; /&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--- 命名空间 namespace --&gt; &lt;mapper namespace=&quot;com.brave.dao.UpmsUserDao&quot;&gt; &lt;!-- 结果集映射 --&gt; &lt;resultMap type=&quot;com.brave.model.UpmsUser&quot; id=&quot;upmsUser&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;loginname&quot; property=&quot;loginname&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;realname&quot; property=&quot;realname&quot;/&gt; &lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;is_locked&quot; property=&quot;locked&quot;/&gt; &lt;result column=&quot;gmt_create&quot; property=&quot;gmtCreate&quot;/&gt; &lt;result column=&quot;gmt_modified&quot; property=&quot;gmtModified&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 查询sql --&gt; &lt;select id=&quot;selectOne&quot; resultMap=&quot;upmsUser&quot;&gt; select * from upms_user where user_id = #{userId} &lt;/select&gt; &lt;select id=&quot;selectUser&quot; resultMap=&quot;upmsUser&quot;&gt; select * from upms_user &lt;/select&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into upms_user (user_id,loginname,password,realname,is_locked) value(#{userId},#{loginname},#{password},#{realname},#{locked}) &lt;/insert&gt; &lt;/mapper&gt; 上面我们通过 mybatis配置xml 构建了SqlSessionFactory，有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句： SqlSession sqlSession = sqlSessionFactory.openSession(); try { //这里我们通过 命名空间+sql语句的Id来执行映射的sql语句 UpmsUser upmsUser = sqlSession.selectOne(&quot;com.brave.dao.UpmsUserDao.selectOne&quot;, 10001L); }finally { sqlSession.close(); } 构建 SqlSessionFactory，获取 SqlSession 从上面的 mybatis配置和 xml映射文件配置 我们可以了解到这样一个流程： 通过流读取 mabatis 配置文件信息，使用 SqlSessionFactoryBuilder 构建SqlSessionFactory，再从SqlSessionFactory 中获取 SqlSession 实例，通过 SqlSession 实例来直接执行已映射的 SQL 语句在这里我们需要理解这三个对象的不同作用域和生命周期，错误的使用会导致非常严重的并发问题。 public class SqlSessionFactoryUtil { private static SqlSessionFactory sqlSessionFactory; /** * 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。 * SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。 * 而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 * * SqlSessionFactoryBuilder 最佳作用域是方法作用域（也就是局部方法变量） * SqlSessionFactory 最佳作用域是应用作用域 * SqlSession 最佳的作用域是请求或方法作用域 */ public static SqlSessionFactory getSqlSessionFactory() { if (sqlSessionFactory != null) { return sqlSessionFactory; } InputStream inputStream; try { inputStream = Resources.getResourceAsStream(&quot;conf/mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } return sqlSessionFactory; } } 我们可以创建一个 baseDao 获取 SqlSession public class BaseDaoImpl implements BaseDao { @Override public SqlSession getSqlSession() { SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtil.getSqlSessionFactory(); return sqlSessionFactory.openSession(); } } 通过 命名空间+sql语句的Id来执行映射的sql语句 public class UpmsUserDaoImpl extends BaseDaoImpl implements UpmsUserDao { @Override public UpmsUser selectOne(Long userId) { SqlSession sqlSession = getSqlSession(); UpmsUser upmsUser = null; try { upmsUser = sqlSession.selectOne(&quot;com.brave.dao.UpmsUserDao.selectOne&quot;, userId); } finally { sqlSession.close(); } return upmsUser; } @Override public List&lt;UpmsUser&gt; selectUser() { SqlSession sqlSession = getSqlSession(); List&lt;UpmsUser&gt; upmsUsers = null; try { upmsUsers = sqlSession.selectList(&quot;com.brave.dao.UpmsUserDao.selectUser&quot;); } finally { sqlSession.close(); } return upmsUsers; } @Override public int insertUser(UpmsUser upmsUser) { SqlSession sqlSession = getSqlSession(); int n = 0; try { n = sqlSession.insert(&quot;com.brave.dao.UpmsUserDao.insertUser&quot;, upmsUser); sqlSession.commit(); } finally { sqlSession.close(); } return n; } } 我们用 Junit 创建测试类测试一下结果 public class UpmsUserDaoImplTest { UpmsUserDao userDao = new UpmsUserDaoImpl(); @Test public void testSelectOne() { System.out.println(userDao.selectOne(10001L).toString()); } @Test public void testSelectUser() { List&lt;UpmsUser&gt; upmsUsers = userDao.selectUser(); for (UpmsUser upmsUser : upmsUsers) { System.out.println(upmsUser.toString()); } } @Test public void testInsertUser() { UpmsUser upmsUser = new UpmsUser(); upmsUser.setUserId(10002L); upmsUser.setLoginname(&quot;zou&quot;); upmsUser.setPassword(&quot;123456&quot;); upmsUser.setLocked(false); int n = userDao.insertUser(upmsUser); System.out.println(&quot;插入&quot; + n + &quot;行&quot;); } } 到了这里我们其实可以发现，我们在映射文件中写的 命名空间 和 完全限定名 是一样的，如com.brave.dao.UpmsUserDao ，这个命名可以直接映射到在命名空间中同名的 Mapper 类，并将已映射的 sql 语句中的名字、参数和返回类型匹配成方法 这样我们就可以像上面那样很容易地调用这个对应 Mapper 接口的方法，只需要接口，不需要写实现类。我们的接口方法名称和 映射文件中的sql语句Id一致的话可以直接调用。 UpmsUserDao.java public interface UpmsUserDao extends BaseDao { UpmsUser selectOne(Long userId); List&lt;UpmsUser&gt; selectUser(); int insertUser(UpmsUser upmsUser); } 测试 @Test public void testInterface() { SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtil.getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); //可以直接映射到在命名空间中同名的 Mapper 类 （只要映射接口类就可以了，不需要实现） UpmsUserDao upmsUserDao = session.getMapper(UpmsUserDao.class); List&lt;UpmsUser&gt; upmsUsers = upmsUserDao.selectUser(); for (UpmsUser upmsUser : upmsUsers) { System.out.println(upmsUser.toString()); } } ","link":"https://1958818905.github.io/post/spring-boot-zhong-mybatis-de-shi-yong-he-pei-zhi-yi/"},{"title":"SpringBoot Jpa 的使用","content":"Spring Boot Jpa 介绍 Jpa 是什么？ Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象/关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。 值得注意的是，Jpa是在充分吸收了现有 Hibernate，TopLink，JDO 等 ORM 框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，Jpa 受到了极大的支持和赞扬，其中就包括了 Spring 与 EJB3. 0的开发团队。 注意：Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。 Spring Boot Jpa Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data Jpa 可以极大提高开发效率！ Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现。 基本查询 基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。 预先生成方法 继承 JpaRepository Spring Boot Jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等 public interface UserRepository extends JpaRepository&lt;User, Long&gt; { } - 使用默认方法 ```java @Test public void testBaseQuery() throws Exception { User user=new User(); userRepository.findAll(); userRepository.findOne(1l); userRepository.save(user); userRepository.delete(user); userRepository.count(); userRepository.exists(1l); // ... } 自定义简单查询 自定义的简单查询就是根据方法名来自动生成 SQL，主要的语法是findXXBy,readAXXBy,queryXXBy,countXXBy, getXXBy后面跟属性名称： User findByUserName(String userName); 也使用一些加一些关键字And 、 Or User findByUserNameOrEmail(String username, String email); 修改、删除、统计也是类似语法 Long deleteById(Long id); Long countByUserName(String userName) 基本上 SQL 体系中的关键词都可以使用，例如： LIKE 、 IgnoreCase、 OrderBy。 List&lt;User&gt; findByEmailLike(String email); User findByUserNameIgnoreCase(String userName); List&lt;User&gt; findByUserNameOrderByEmailDesc(String email); 复杂查询 在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义 SQL 分页查询 分页查询在实际使用中非常普遍了，Spring Boot Jpa 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数Pageable ,当查询中有多个参数的时候Pageable建议做为最后一个参数传入. Page&lt;User&gt; findALL(Pageable pageable); Page findByUserName(String userName,Pageable pageable); - Pageable 是 Spring 封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则 ```java @Test public void testPageQuery() throws Exception { int page=1,size=10; Sort sort = new Sort(Direction.DESC, &quot;id&quot;); Pageable pageable = new PageRequest(page, size, sort); userRepository.findALL(pageable); userRepository.findByUserName(&quot;testName&quot;, pageable); } 限制查询 有时候我们只需要查询前N个元素，或者支取前一个实体。 User findFirstByOrderByLastnameAsc(); User findTopByOrderByAgeDesc(); Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable); List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort); List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable); 自定义SQL查询 其实 Spring Data 觉大部分的 SQL 都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的 SQL 来查询，Spring Data 也是完美支持的；在 SQL 的查询方法上面使用@Query注解，如涉及到删除和修改在需要加上@Modifying.也可以根据需要添加 @Transactional对事物的支持，查询超时的设置等。 @Modifying @Query(&quot;update User u set u.userName = ?1 where u.id = ?2&quot;) int modifyByIdAndUserId(String userName, Long id); @Transactional @Modifying @Query(&quot;delete from User where id = ?1&quot;) void deleteByUserId(Long id); @Transactional(timeout = 10) @Query(&quot;select u from User u where u.emailAddress = ?1&quot;) User findByEmailAddress(String emailAddress); 多表查询 多表查询 Spring Boot Jpa 中有两种实现方式，第一种是利用 Hibernate 的级联查询来实现，第二种是创建一个结果集的接口来接收连表查询后的结果，这里主要第二种方式。 首先需要定义一个结果集的接口类。 public interface HotelSummary { City getCity(); String getName(); Double getAverageRating(); default Integer getAverageRatingRounded() { return getAverageRating() == null ? null : (int) Math.round(getAverageRating()); } } 查询的方法返回类型设置为新创建的接口 @Query(&quot;select h.city as city, h.name as name, avg(r.rating) as averageRating &quot; - &quot;from Hotel h left outer join h.reviews r where h.city = ?1 group by h&quot;) Page&lt;HotelSummary&gt; findByCity(City city, Pageable pageable); @Query(&quot;select h.name as name, avg(r.rating) as averageRating &quot; - &quot;from Hotel h left outer join h.reviews r group by h&quot;) Page&lt;HotelSummary&gt; findByCity(Pageable pageable); 使用 Page&lt;HotelSummary&gt; hotels = this.hotelRepository.findByCity(new PageRequest(0, 10, Direction.ASC, &quot;name&quot;)); for(HotelSummary summay:hotels){ System.out.println(&quot;Name&quot; +summay.getName()); } ","link":"https://1958818905.github.io/post/springboot/"},{"title":"Spring Boot：Spring Boot 中 Redis 的使用","content":"Spring Boot 对常用的数据库支持外，对 Nosql 数据库也进行了封装自动化。 Redis 介绍 Redis 是目前业界使用最广泛的内存数据存储。相比 Memcached，Redis 支持更丰富的数据结构，例如 hashes, lists, sets 等，同时支持数据持久化。除此之外，Redis 还提供一些类数据库的特性，比如事务，HA，主从库。可以说 Redis 兼具了缓存系统和数据库的一些特性，因此有着丰富的应用场景。本文介绍 Redis 在 Spring Boot 中两个典型的应用场景。 如何使用 引入依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; org.apache.commons commons-pool2 ``` - Spring Boot 提供了对 Redis 集成的组件包：spring-boot-starter-data-redisspring-boot-starter-data-redis依赖于spring-data-redis 和 lettuce 。Spring Boot 1.0 默认使用的是 Jedis 客户端，2.0 替换成 Lettuce，但如果你从 Spring Boot 1.5.X 切换过来，几乎感受不大差异，这是因为 spring-boot-starter-data-redis 为我们隔离了其中的差异性。 - Lettuce 是一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 netty NIO 框架来高效地管理多个连接。 2. 添加配置文件 ``` # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器地址 spring.redis.host=localhost # Redis服务器连接端口 spring.redis.port=6379 # Redis服务器连接密码（默认为空） spring.redis.password= # 连接池最大连接数（使用负值表示没有限制） 默认 8 spring.redis.lettuce.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1 spring.redis.lettuce.pool.max-wait=-1 # 连接池中的最大空闲连接 默认 8 spring.redis.lettuce.pool.max-idle=8 # 连接池中的最小空闲连接 默认 0 spring.redis.lettuce.pool.min-idle=0 ``` 3. 添加 cache 的配置类 ``` @Configuration @EnableCaching public class RedisConfig extends CachingConfigurerSupport{ @Bean public KeyGenerator keyGenerator() { return new KeyGenerator() { @Override public Object generate(Object target, Method method, Object... params) { StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) { sb.append(obj.toString()); } return sb.toString(); } }; } } - 注意我们使用了注解：@EnableCaching来开启缓存。 4. 直接使用 @RunWith(SpringRunner.class) @SpringBootTest public class TestRedis { @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate redisTemplate; @Test public void test() throws Exception { stringRedisTemplate.opsForValue().set(&quot;aaa&quot;, &quot;111&quot;); Assert.assertEquals(&quot;111&quot;, stringRedisTemplate.opsForValue().get(&quot;aaa&quot;)); } @Test public void testObj() throws Exception { User user=new User(&quot;aa@126.com&quot;, &quot;aa&quot;, &quot;aa123456&quot;, &quot;aa&quot;,&quot;123&quot;); ValueOperations&lt;String, User&gt; operations=redisTemplate.opsForValue(); operations.set(&quot;com.neox&quot;, user); operations.set(&quot;com.neo.f&quot;, user,1, TimeUnit.SECONDS); Thread.sleep(1000); //redisTemplate.delete(&quot;com.neo.f&quot;); boolean exists=redisTemplate.hasKey(&quot;com.neo.f&quot;); if(exists){ System.out.println(&quot;exists is true&quot;); }else{ System.out.println(&quot;exists is false&quot;); } // Assert.assertEquals(&quot;aa&quot;, operations.get(&quot;com.neo.f&quot;).getUserName()); } } - 以上都是手动使用的方式，如何在查找数据库的时候自动使用缓存呢，看下面； 5. 自动根据方法生成缓存 @RestController public class UserController { @RequestMapping(&quot;/getUser&quot;) @Cacheable(value=&quot;user-key&quot;) public User getUser() { User user=new User(&quot;aa@126.com&quot;, &quot;aa&quot;, &quot;aa123456&quot;, &quot;aa&quot;,&quot;123&quot;); System.out.println(&quot;若下面没出现“无缓存的时候调用”字样且能打印出数据表示测试成功&quot;); return user; } } - 其中 value 的值就是缓存到 Redis 中的 key ","link":"https://1958818905.github.io/post/spring-bootspring-boot-zhong-redis-de-shi-yong/"},{"title":"SpringBoot注解","content":"SpringBoot注解的优缺点 优点 快速构建项目。 对主流开发框架的无配置集成。 项目可独立运行，无须外部依赖Servlet容器。 提供运行时的应用监控。 极大的提高了开发、部署效率。 与云计算的天然集成。 缺点： 版本迭代速度很快，一些模块改动很大 由于不用自己做配置，报错时很难定位 网上现成的解决方案比较少 注解 SpringBootApplication – 主配置类 效果：说明这个类就是SpringBoot的主配置类，SpringBoot就应该运行主配置类的main方法执行程序。 @SpringBootApplication public class SpringBootMaven { public static void main(String[] args) { SpringApplication.run(SpringBootMaven.class, args); } } 继承@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan @SpringBootConfiguration：继承@Configuration，Spring配置注解，将当前类声明的一个或多个@Bean注解标记的方法纳入Spring容器，实例名就是方法名. @EnableAutoConfiguration：继承@AutoConfigurationPackage， 导入了AutoConfigurationImportSelector.class AutoConfigurationPackages.Registrar.class根据添加的jar包来配置项目的默认配置。 @ComponentScan：扫描当前包及其子包下被@Component，@Controller，@Service， @Repository注解标记的类并纳入到spring容器中进行管理 EnableAutoConfiguration -自动装配 效果：借助AutoConfigurationImportSelector.class，为SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器 @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) @RestController – 控制器 @RestController == @ResponseBody + @Controller @ResponseBody：标记在类上，表示类下所有方法返回一条语句给网站，@Controller：标记当前类为控制器. @RestController public class SpringbootiniApplication { @RequestMapping(&quot;/&quot;) String hello(){ return &quot;hello world quick&quot;; } } @ConfigurationProperties – 配置属性绑定 把全局/主配yml/properties的配置信息注入到POJO（全局 &gt; application.yml/properties） 需要把当前类标记为组件（@Component），添加属性prefix = “xx”，xx为yml里的key @Component @ConfigurationProperties(prefix = &quot;person&quot;) public class Person { int age; String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 而且根据SpringBoot文档，还需要添加依赖处理器 &lt;!-- yml依赖处理器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 然后重新启动springboot @PropertySource – 引入SpringBoot配置 当@ConfigurationProperties需要从副配置文件拿数据时，可用@PropertySource手动引入副配置，value可指定多个路径 @Component @ConfigurationProperties(prefix = &quot;person&quot;) @PropertySource(value = {&quot;classpath:person.properties&quot;}) public class Person { int age; String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 相同key优先级：全局配置 &gt; 副配置 上面用person.properties而不用person.yml不是没有原因的，yml除了主配，其他配置不生效 @ImportSource – 引入Spring配置@ImportSource – 引入Spring配置 在SpringBoot中，引入bean.xml（Spring配置文件），需要在主类配置该注解，可导入多个配置文件 @SpringBootApplication @ImportResource(locations = {&quot;classpath:bean.xml&quot;}) public class SpringbootiniApplication { public static void main(String[] args) { SpringApplication.run(SpringbootiniApplication.class, args); } } @Configuration – 注解代替Spring配置 Spring注解，标记类后当前类成配置类，当前类的@Bean注解即 applicationContext.xml == @Configuration + @Bean + @ComponentSca… SpringBoot推荐 =&gt; 注解代替配置文件 @Configuration public class MyAppConfig { @Bean public Student student(){ System.out.println(&quot;@bean is ok&quot;); return new Student(); } } class Student{} @Bean：将方法返回值添加到容器中；容器中这个组件默认id就是方法名 @ResponseBody – 文本返回 标注方法上，如果你有返回值，返回值变文本格式输出，若没有标注，则分发器会走视图解析器，然后报错说/template下找不到视图，如果你只是ajax异步回来处理数据存储，不需要返回页面则无需标注 @RequestMapping(&quot;/login&quot;) @ResponseBody public User login(User user){ return user; } User字段：userName pwd 那么在前台接收到的数据为：’{“userName”:“xxx”,“pwd”:“xxx”}’ @Transactional – 事务 如下有一个保存用户的方法，加入 @Transactional 注解，使用默认配置，抛出异常之后，事务会自动回滚，数据不会插入到数据库。 @Transactional public void save() { User user = new User(&quot;服部半藏&quot;); userMapper.insertSelective(user); if (true) { throw new RuntimeException(&quot;save 抛异常了&quot;); } } @Param – 绑定EL和参数 mybatis提示类型绑定问题 @Select(&quot;select * from myuser where loginname=#{loginname} and password=#{password}&quot;) User findWithLoginnameAndPassword(@Param(&quot;loginname&quot;)int loginname, @Param(&quot;password&quot;)String password); ","link":"https://1958818905.github.io/post/ce-shi/"}]}